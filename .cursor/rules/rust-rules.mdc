---
alwaysApply: true
---

# Ferros Rust Development Rules

## Project Overview
Ferros is a Rust-native debugger built as a workspace of multiple crates. Each crate has a specific responsibility:
- `ferros`: Command-line interface
- `ferros-core`: Low-level debugging primitives and process control
- `ferros-mir`: MIR integration, introspection, and analysis
- `ferros-ui`: Optional GUI for visualization
- `ferros-protocol`: Communication layer between debugger and frontend
- `ferros-utils`: Shared utilities, logging, config, and helpers

## Code Style & Formatting

### Formatting Rules
- Always run `cargo fmt --all` before committing
- Follow the project's `rustfmt.toml`

### Linting Rules
- Always run `cargo clippy --all -- -D warnings` before committing

## Workspace Configuration

### Crate Structure
- All crates live under `/crates` directory
- All crates inherit workspace lints via `[lints] workspace = true`

## Error Handling

### Error Types
- Use `thiserror` for library crates (`ferros-core`, `ferros-mir`, `ferros-protocol`)
- Use `Result<T, E>` for fallible operations
- Prefer `?` operator over explicit `match` when propagating errors

### Error Messages
- Write clear, actionable error messages
- Include relevant context (file paths, line numbers, variable values when safe)
- Use structured error types with `#[error("...")]` attributes

## Async Programming

### Async Patterns
- Use `tokio` as the async runtime
- Prefer `async fn` over manual `Future` implementations
- Use `tokio::spawn` for concurrent tasks
- Use `tokio::select!` for concurrent operations
- Prefer `tokio::sync::mpsc` for channels
- Use `Arc` and `Mutex`/`RwLock` for shared state in async contexts

### Async Safety
- Ensure all async operations are properly awaited
- Use `#[tokio::test]` for async tests
- Be mindful of cancellation and cleanup in async code

## Documentation

### Public API Documentation
- Document all public functions, types, and modules with Rustdoc comments (`///`)
- Use `# Errors` sections to document error conditions
- Use `# Panics` sections if functions can panic

### Code Comments
- Use `//` for inline comments
- Use `/* */` for multi-line comments when needed
- Keep comments up-to-date with code changes

## Cross-Platform Considerations

### Platform-Specific Code
- Use `#[cfg(target_os = "...")]` for platform-specific implementations
- Support Linux (`ptrace`), macOS (Mach ports), and Windows (WinDbg APIs)
- Document platform-specific behavior

### Conditional Compilation
- Use feature flags for optional functionality
- Document feature flags in `Cargo.toml`
- Use `#[cfg(feature = "...")]` for feature-gated code
- **Platform-specific code**: Always use `#[cfg(target_os = "...")]` for platform-specific implementations
- **CI Compatibility**: Ensure platform-specific tests/examples compile on all platforms (use conditional compilation)
  - Tests/examples should not cause compilation errors on non-target platforms
  - Use `#[cfg(target_os = "...")]` to scope platform-specific code
  - Provide fallback implementations for non-target platforms when needed

## Git & Commit Messages

### Commit Message Format
Follow [Conventional Commits](https://www.conventionalcommits.org/):
- `feat(crate): description` - new feature
- `fix(crate): description` - bug fix
- `refactor(crate): description` - non-breaking code improvements
- `docs(crate): description` - documentation updates
- `test(crate): description` - adding or improving tests
- `chore(crate): description` - tooling or maintenance

## Build & Development Workflow

### Before Committing
1. Run `just check`
5. Ensure all linter errors are resolved

### Development Commands
- `just build` - Build all crates
- `just test` - Run all tests
- `cargo clippy` - Run linter
- `just fmt` - Format code
- `just docs` - Build and open documentation

## Additional Best Practices

### Type Safety
- Prefer strong types over primitives (e.g., `struct ProcessId(u32)` over `u32`)
- Use newtype patterns for domain concepts
- Leverage Rust's type system for compile-time guarantees

### Code Organization
- Keep modules focused and cohesive
- Use `mod.rs` for module organization
- Group related functionality together
- Avoid deep nesting (prefer flat module structure)

### Naming Conventions
- Use `snake_case` for functions and variables
- Use `PascalCase` for types and traits
- Use `SCREAMING_SNAKE_CASE` for constants
- Use descriptive names that convey intent
- Avoid abbreviations unless widely understood

### Resource Management
- Use RAII patterns for resource cleanup
- Implement `Drop` for custom resource types
- Use `std::sync::Arc` for shared ownership
- Prefer direct lifetime syntax over cloning when possible

## Package installation rules

- Always use cargo install <package> over adding your own version number. This way we get the latest version of the package.
- If working in a workspacce, use cargo add <name> --package <workspace-name>
