//! DWARF type extraction and introspection.
//!
//! This module provides functionality to extract type information from DWARF
//! debugging information. It can parse structs, enums, unions, and trait objects,
//! extracting their fields, variants, and other metadata.
//!
//! ## Type Extraction
//!
//! The `TypeExtractor` walks through DWARF compilation units and type units,
//! searching for type definitions that match a given name. It builds a `TypeSummary`
//! that contains:
//!
//! - Type name and kind (struct, enum, union, trait object)
//! - Size in bits
//! - Fields with names, types, and offsets
//! - Variants (for enums) with discriminants
//!
//! ## Async State Machine Detection
//!
//! The extractor can detect Rust async state machines by looking for specific
//! patterns in type names and fields (e.g., `__state`, `__poll_state`, `GenFuture`).

use gimli::{
    Attribute, AttributeValue, DebugTypeSignature, DebuggingInformationEntry, Reader, Unit, UnitOffset, UnitSectionOffset,
    UnitType, constants,
};

use super::demangle::{is_trait_object, map_dwarf_error};
use super::{OwnedDwarf, OwnedReader};
use crate::error::Result;

const MAX_TYPE_REF_DEPTH: usize = 32;

/// Summary of a type extracted from DWARF.
///
/// This structure contains all the information about a type that can be extracted
/// from DWARF debugging information. It includes the type's name, kind, size,
/// fields (for structs/unions), and variants (for enums).
///
/// ## Example
///
/// For a Rust struct like:
/// ```rust
/// struct Point
/// {
///     x: i32,
///     y: i32,
/// }
/// ```
///
/// The `TypeSummary` would contain:
/// - `name`: "Point" or "path::to::Point"
/// - `kind`: `TypeKind::Struct`
/// - `size_bits`: `Some(64)` (assuming 32-bit integers)
/// - `fields`: Two `TypeField` entries for `x` and `y`
/// - `variants`: Empty (not an enum)
#[derive(Debug, Clone)]
pub struct TypeSummary
{
    /// Fully qualified type name (e.g., "std::option::Option" or "Point")
    pub name: String,
    /// The kind of type (struct, enum, union, trait object, or unknown)
    pub kind: TypeKind,
    /// Size of the type in bits, if available
    ///
    /// This is extracted from `DW_AT_byte_size` or `DW_AT_bit_size` attributes.
    /// `None` if the size is not available in DWARF.
    pub size_bits: Option<u64>,
    /// Fields of the type (for structs, unions, and enum variants)
    ///
    /// Each field contains its name, type, and offset within the containing type.
    pub fields: Vec<TypeField>,
    /// Variants of the type (for enums)
    ///
    /// Each variant contains its name, discriminant value, and fields (if it's
    /// a tuple or struct variant).
    pub variants: Vec<TypeVariant>,
}

impl TypeSummary
{
    /// Check if this type represents a Rust async state machine.
    ///
    /// This method uses heuristics to detect async state machines generated by
    /// the Rust compiler. It looks for:
    ///
    /// - Type names containing `::{{async}}`, `::{{generator}}`, or `::{{opaque}}`
    /// - Fields named `__state`, `__poll_state`, `__awaiter`, or `__resume_state`
    /// - Fields with types containing `core::future` or `GenFuture`
    /// - Variants named `Pending`, `Ready`, `Complete`, `Terminated`, or `Resolved`
    ///
    /// ## Returns
    ///
    /// `true` if the type appears to be an async state machine, `false` otherwise.
    ///
    /// ## Example
    ///
    /// ```rust
    /// use ferros_core::symbols::TypeSummary;
    ///
    /// // This would return true for types like:
    /// // - `std::future::GenFuture<...>`
    /// // - Types with `__state` fields and `core::future` types
    /// ```
    pub fn is_async_state_machine(&self) -> bool
    {
        if self.name.contains("::{{async}}") || self.name.contains("::{{generator}}") || self.name.contains("::{{opaque}}") {
            return true;
        }

        let state_field = self.fields.iter().any(|field| {
            matches!(
                field.name.as_deref(),
                Some("__state") | Some("__poll_state") | Some("__awaiter") | Some("__resume_state")
            )
        });
        let await_field = self
            .fields
            .iter()
            .any(|field| field.name.as_deref().map(|name| name.contains("await")).unwrap_or(false));
        let future_field = self.fields.iter().any(|field| {
            field
                .ty
                .as_deref()
                .map(|ty| ty.contains("core::future") || ty.contains("GenFuture"))
                .unwrap_or(false)
        });
        let variant_hint = self.variants.iter().any(|variant| {
            matches!(
                variant.name.as_deref(),
                Some("Pending") | Some("Ready") | Some("Complete") | Some("Terminated") | Some("Resolved")
            )
        });

        match self.kind {
            TypeKind::Struct | TypeKind::TraitObject => state_field && (await_field || future_field),
            TypeKind::Enum => variant_hint && (state_field || future_field),
            _ => false,
        }
    }
}

/// The kind of type extracted from DWARF.
///
/// This enum categorizes types based on their DWARF tag and structure.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TypeKind
{
    /// A structure type (struct in Rust, class/struct in C++)
    ///
    /// Contains named fields with specific offsets. May also represent an enum
    /// if it has variant parts (Rust enums are represented as structs with variants).
    Struct,
    /// An enumeration type
    ///
    /// Contains variants with discriminant values. In Rust, this represents
    /// both C-like enums and enum variants.
    Enum,
    /// A union type
    ///
    /// Contains fields that share the same memory location. In Rust, this
    /// represents `union` types (unsafe).
    Union,
    /// A trait object (dyn Trait)
    ///
    /// Represents a trait object in Rust, which is a fat pointer containing
    /// a data pointer and a vtable pointer.
    TraitObject,
    /// Unknown or unsupported type
    ///
    /// The type was found in DWARF but doesn't match any of the known categories.
    Unknown,
}

/// A field within a type (struct, union, or enum variant).
///
/// Represents a single field with its name, type, and offset within the containing type.
#[derive(Debug, Clone)]
pub struct TypeField
{
    /// Field name, if available
    ///
    /// May be `None` for tuple struct fields (e.g., `(i32, i32)`) or anonymous fields.
    pub name: Option<String>,
    /// Type name of the field, if available
    ///
    /// This is the fully qualified type name (e.g., "i32", "std::string::String").
    /// May be `None` if the type information is not available in DWARF.
    pub ty: Option<String>,
    /// Offset of the field within the containing type, in bits
    ///
    /// This is extracted from `DW_AT_data_member_location` or `DW_AT_data_bit_offset`.
    /// `None` if the offset is not available.
    pub offset_bits: Option<u64>,
}

/// A variant of an enumeration type.
///
/// Represents a single variant (discriminant) of an enum, including its name,
/// discriminant value, and fields (for tuple or struct variants).
#[derive(Debug, Clone)]
pub struct TypeVariant
{
    /// Variant name, if available
    ///
    /// For Rust enums, this is the variant name (e.g., "Some", "None", "Ok", "Err").
    /// May be `None` for C-like enums without names.
    pub name: Option<String>,
    /// Discriminant value for this variant
    ///
    /// This is the integer value that identifies this variant in the enum.
    /// For Rust enums, this is extracted from `DW_AT_discr_value`.
    /// For C-like enums, this is extracted from `DW_AT_const_value`.
    pub discriminant: Option<i64>,
    /// Fields of this variant (for tuple or struct variants)
    ///
    /// Empty for unit variants (e.g., `None`). Contains fields for tuple variants
    /// (e.g., `Some(T)`) and struct variants (e.g., `Ok { value: T }`).
    pub fields: Vec<TypeField>,
}

pub(crate) struct TypeExtractor<'a>
{
    dwarf: &'a OwnedDwarf,
    units: Vec<Unit<OwnedReader>>,
}

impl<'a> TypeExtractor<'a>
{
    pub(crate) fn new(dwarf: &'a OwnedDwarf) -> Result<Self>
    {
        let mut units = Vec::new();
        let mut headers = dwarf.units();
        while let Some(header) = headers
            .next()
            .map_err(|err| map_dwarf_error("reading .debug_info unit header", err))?
        {
            units.push(
                dwarf
                    .unit(header)
                    .map_err(|err| map_dwarf_error("parsing compilation unit", err))?,
            );
        }

        let mut type_headers = dwarf.type_units();
        while let Some(header) = type_headers
            .next()
            .map_err(|err| map_dwarf_error("reading .debug_types unit header", err))?
        {
            units.push(dwarf.unit(header).map_err(|err| map_dwarf_error("parsing type unit", err))?);
        }

        Ok(Self { dwarf, units })
    }

    pub(crate) fn describe(&self, target: &str) -> Result<Option<TypeSummary>>
    {
        for unit in &self.units {
            if let Some(summary) = self.describe_in_unit(unit, target)? {
                return Ok(Some(summary));
            }
        }
        Ok(None)
    }

    fn describe_in_unit(&self, unit: &Unit<OwnedReader>, target: &str) -> Result<Option<TypeSummary>>
    {
        let mut cursor = unit.entries();
        while let Some((_delta, entry)) = cursor.next_dfs().map_err(|err| map_dwarf_error("traversing DIE tree", err))? {
            if !matches!(
                entry.tag(),
                constants::DW_TAG_structure_type
                    | constants::DW_TAG_class_type
                    | constants::DW_TAG_union_type
                    | constants::DW_TAG_enumeration_type
            ) {
                continue;
            }
            let Some(name) = self.entry_name(unit, entry)? else {
                continue;
            };
            if !Self::names_match(&name, target) {
                continue;
            }
            let summary = self.build_summary(unit, entry.clone(), name)?;
            return Ok(Some(summary));
        }
        Ok(None)
    }

    fn build_summary(
        &self,
        unit: &Unit<OwnedReader>,
        entry: DebuggingInformationEntry<'_, '_, OwnedReader>,
        name: String,
    ) -> Result<TypeSummary>
    {
        let mut kind = match entry.tag() {
            constants::DW_TAG_structure_type | constants::DW_TAG_class_type => TypeKind::Struct,
            constants::DW_TAG_union_type => TypeKind::Union,
            constants::DW_TAG_enumeration_type => TypeKind::Enum,
            _ => TypeKind::Unknown,
        };

        if matches!(entry.tag(), constants::DW_TAG_structure_type | constants::DW_TAG_class_type) && is_trait_object(&name) {
            kind = TypeKind::TraitObject;
        }

        let mut fields = Vec::new();
        let mut variants = Vec::new();

        match entry.tag() {
            constants::DW_TAG_structure_type | constants::DW_TAG_class_type => {
                let (struct_fields, struct_variants, has_variants) = self.collect_struct_members(unit, entry.offset())?;
                fields = struct_fields;
                variants = struct_variants;
                if has_variants {
                    kind = TypeKind::Enum;
                }
            }
            constants::DW_TAG_union_type => {
                fields = self.collect_union_members(unit, entry.offset())?;
            }
            constants::DW_TAG_enumeration_type => {
                variants = self.collect_enumerators(unit, entry.offset())?;
            }
            _ => {}
        }

        let size_bits = self.entry_size_bits(&entry)?;

        Ok(TypeSummary {
            name,
            kind,
            size_bits,
            fields,
            variants,
        })
    }

    fn entry_size_bits(&self, entry: &DebuggingInformationEntry<'_, '_, OwnedReader>) -> Result<Option<u64>>
    {
        if let Ok(Some(attr)) = entry
            .attr(constants::DW_AT_bit_size)
            .map_err(|err| map_dwarf_error("reading DW_AT_bit_size", err))
            && let Some(bits) = attr.udata_value()
        {
            return Ok(Some(bits));
        }

        if let Ok(Some(attr)) = entry
            .attr(constants::DW_AT_byte_size)
            .map_err(|err| map_dwarf_error("reading DW_AT_byte_size", err))
            && let Some(bytes) = attr.udata_value()
        {
            return Ok(Some(bytes * 8));
        }

        Ok(None)
    }

    fn collect_struct_members(
        &self,
        unit: &Unit<OwnedReader>,
        offset: UnitOffset<usize>,
    ) -> Result<(Vec<TypeField>, Vec<TypeVariant>, bool)>
    {
        let mut fields = Vec::new();
        let mut variants = Vec::new();
        let mut has_variant_part = false;

        let mut tree = unit
            .entries_tree(Some(offset))
            .map_err(|err| map_dwarf_error("building struct tree", err))?;
        let root = tree.root().map_err(|err| map_dwarf_error("navigating struct root", err))?;
        let mut children = root.children();
        while let Some(child) = children
            .next()
            .map_err(|err| map_dwarf_error("iterating struct children", err))?
        {
            let child_entry = child.entry().clone();
            match child_entry.tag() {
                constants::DW_TAG_member => fields.push(self.build_field(unit, &child_entry)?),
                constants::DW_TAG_variant_part => {
                    has_variant_part = true;
                    variants.extend(self.collect_variants_from_offset(unit, child_entry.offset())?);
                }
                _ => {}
            }
        }

        Ok((fields, variants, has_variant_part))
    }

    fn collect_union_members(&self, unit: &Unit<OwnedReader>, offset: UnitOffset<usize>) -> Result<Vec<TypeField>>
    {
        let mut fields = Vec::new();
        let mut tree = unit
            .entries_tree(Some(offset))
            .map_err(|err| map_dwarf_error("building union tree", err))?;
        let root = tree.root().map_err(|err| map_dwarf_error("navigating union root", err))?;
        let mut children = root.children();
        while let Some(child) = children
            .next()
            .map_err(|err| map_dwarf_error("iterating union children", err))?
        {
            let child_entry = child.entry().clone();
            if child_entry.tag() == constants::DW_TAG_member {
                fields.push(self.build_field(unit, &child_entry)?);
            }
        }
        Ok(fields)
    }

    fn collect_variants_from_offset(&self, unit: &Unit<OwnedReader>, offset: UnitOffset<usize>) -> Result<Vec<TypeVariant>>
    {
        let mut variants = Vec::new();
        let mut tree = unit
            .entries_tree(Some(offset))
            .map_err(|err| map_dwarf_error("building variant tree", err))?;
        let node = tree.root().map_err(|err| map_dwarf_error("navigating variant root", err))?;
        let mut children = node.children();
        while let Some(variant_node) = children.next().map_err(|err| map_dwarf_error("iterating variants", err))? {
            let entry = variant_node.entry().clone();
            if entry.tag() != constants::DW_TAG_variant {
                continue;
            }

            let mut field_iter = variant_node.children();
            let mut variant_fields = Vec::new();
            while let Some(field_node) = field_iter
                .next()
                .map_err(|err| map_dwarf_error("iterating variant fields", err))?
            {
                let field_entry = field_node.entry().clone();
                if field_entry.tag() == constants::DW_TAG_member {
                    variant_fields.push(self.build_field(unit, &field_entry)?);
                }
            }

            variants.push(TypeVariant {
                name: self.entry_name(unit, &entry)?,
                discriminant: self.attribute_to_i64(
                    entry
                        .attr(constants::DW_AT_discr_value)
                        .map_err(|err| map_dwarf_error("reading DW_AT_discr_value", err))?,
                )?,
                fields: variant_fields,
            });
        }
        Ok(variants)
    }

    fn collect_enumerators(&self, unit: &Unit<OwnedReader>, offset: UnitOffset<usize>) -> Result<Vec<TypeVariant>>
    {
        let mut variants = Vec::new();
        let mut tree = unit
            .entries_tree(Some(offset))
            .map_err(|err| map_dwarf_error("building enumeration tree", err))?;
        let root = tree
            .root()
            .map_err(|err| map_dwarf_error("navigating enumeration root", err))?;
        let mut children = root.children();
        while let Some(child) = children.next().map_err(|err| map_dwarf_error("iterating enumerators", err))? {
            let entry = child.entry().clone();
            if entry.tag() != constants::DW_TAG_enumerator {
                continue;
            }

            variants.push(TypeVariant {
                name: self.entry_name(unit, &entry)?,
                discriminant: self.attribute_to_i64(
                    entry
                        .attr(constants::DW_AT_const_value)
                        .map_err(|err| map_dwarf_error("reading DW_AT_const_value", err))?,
                )?,
                fields: Vec::new(),
            });
        }
        Ok(variants)
    }

    fn build_field(
        &self,
        unit: &Unit<OwnedReader>,
        entry: &DebuggingInformationEntry<'_, '_, OwnedReader>,
    ) -> Result<TypeField>
    {
        let name = if let Some(attr) = entry
            .attr(constants::DW_AT_name)
            .map_err(|err| map_dwarf_error("reading field name", err))?
        {
            Some(self.attr_to_string(unit, attr.value())?)
        } else {
            None
        };

        let ty = if let Some(attr) = entry
            .attr(constants::DW_AT_type)
            .map_err(|err| map_dwarf_error("reading field type", err))?
        {
            self.resolve_type_name(unit, attr.value(), 0)?
        } else {
            None
        };

        let offset_bits = self.field_offset_bits(entry)?;

        Ok(TypeField { name, ty, offset_bits })
    }

    fn field_offset_bits(&self, entry: &DebuggingInformationEntry<'_, '_, OwnedReader>) -> Result<Option<u64>>
    {
        if let Ok(Some(attr)) = entry
            .attr(constants::DW_AT_data_bit_offset)
            .map_err(|err| map_dwarf_error("reading DW_AT_data_bit_offset", err))
            && let Some(bits) = attr.udata_value()
        {
            return Ok(Some(bits));
        }

        if let Ok(Some(attr)) = entry
            .attr(constants::DW_AT_data_member_location)
            .map_err(|err| map_dwarf_error("reading DW_AT_data_member_location", err))
            && let Some(bytes) = attr.udata_value()
        {
            return Ok(Some(bytes * 8));
        }

        Ok(None)
    }

    fn attribute_to_i64(&self, attr: Option<Attribute<OwnedReader>>) -> Result<Option<i64>>
    {
        Ok(attr.and_then(|attribute| {
            attribute
                .sdata_value()
                .or_else(|| attribute.udata_value().map(|value| value as i64))
        }))
    }

    fn entry_name(
        &self,
        unit: &Unit<OwnedReader>,
        entry: &DebuggingInformationEntry<'_, '_, OwnedReader>,
    ) -> Result<Option<String>>
    {
        if let Some(attr) = entry
            .attr(constants::DW_AT_name)
            .map_err(|err| map_dwarf_error("reading DW_AT_name", err))?
        {
            return Ok(Some(self.attr_to_string(unit, attr.value())?));
        }
        if let Some(attr) = entry
            .attr(constants::DW_AT_linkage_name)
            .map_err(|err| map_dwarf_error("reading DW_AT_linkage_name", err))?
        {
            return Ok(Some(self.attr_to_string(unit, attr.value())?));
        }
        Ok(None)
    }

    fn attr_to_string(&self, unit: &Unit<OwnedReader>, value: AttributeValue<OwnedReader>) -> Result<String>
    {
        let reader = self
            .dwarf
            .attr_string(unit, value)
            .map_err(|err| map_dwarf_error("resolving DWARF string", err))?;
        let owned = match reader.to_string() {
            Ok(cow) => cow.into_owned(),
            Err(_) => reader
                .to_string_lossy()
                .map_err(|err| map_dwarf_error("decoding DWARF string", err))?
                .into_owned(),
        };
        Ok(owned)
    }

    fn resolve_type_name(
        &self,
        unit: &Unit<OwnedReader>,
        value: AttributeValue<OwnedReader>,
        depth: usize,
    ) -> Result<Option<String>>
    {
        if depth >= MAX_TYPE_REF_DEPTH {
            return Ok(None);
        }

        match value {
            AttributeValue::UnitRef(offset) => self.resolve_type_name_at_offset(unit, offset, depth + 1),
            AttributeValue::DebugInfoRef(offset) => {
                let target = UnitSectionOffset::from(offset);
                if let Some((target_unit, unit_offset)) = self.find_unit_for_offset(target) {
                    self.resolve_type_name_at_offset(target_unit, unit_offset, depth + 1)
                } else {
                    Ok(None)
                }
            }
            AttributeValue::DebugTypesRef(signature) => self.resolve_type_name_for_signature(signature, depth + 1),
            _ => Ok(None),
        }
    }

    fn resolve_type_name_at_offset(
        &self,
        unit: &Unit<OwnedReader>,
        offset: UnitOffset<usize>,
        depth: usize,
    ) -> Result<Option<String>>
    {
        let die = unit
            .entry(offset)
            .map_err(|err| map_dwarf_error("resolving type reference", err))?;
        if let Some(name) = self.entry_name(unit, &die)? {
            return Ok(Some(name));
        }
        if let Some(attr) = die
            .attr(constants::DW_AT_type)
            .map_err(|err| map_dwarf_error("reading nested type", err))?
        {
            let inner = self.resolve_type_name(unit, attr.value(), depth + 1)?;
            return Ok(inner);
        }
        Ok(None)
    }

    fn resolve_type_name_for_signature(&self, signature: DebugTypeSignature, depth: usize) -> Result<Option<String>>
    {
        for unit in &self.units {
            match unit.header.type_() {
                UnitType::Type {
                    type_signature,
                    type_offset,
                }
                | UnitType::SplitType {
                    type_signature,
                    type_offset,
                } if type_signature == signature => {
                    return self.resolve_type_name_at_offset(unit, type_offset, depth + 1);
                }
                _ => {}
            }
        }
        Ok(None)
    }

    fn find_unit_for_offset(&self, target: UnitSectionOffset<usize>) -> Option<(&Unit<OwnedReader>, UnitOffset<usize>)>
    {
        self.units
            .iter()
            .find_map(|unit| target.to_unit_offset(unit).map(|offset| (unit, offset)))
    }

    fn names_match(candidate: &str, wanted: &str) -> bool
    {
        candidate == wanted || candidate.strip_prefix("::") == Some(wanted) || wanted.strip_prefix("::") == Some(candidate)
    }
}
